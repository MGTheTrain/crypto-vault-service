// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.0--rc2
// source: service.proto

package __

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BlobUploadServiceClient is the client API for BlobUploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobUploadServiceClient interface {
	UploadBlob(ctx context.Context, in *UploadKeyRequest, opts ...grpc.CallOption) (*BlobMetaResponse, error)
}

type blobUploadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobUploadServiceClient(cc grpc.ClientConnInterface) BlobUploadServiceClient {
	return &blobUploadServiceClient{cc}
}

func (c *blobUploadServiceClient) UploadBlob(ctx context.Context, in *UploadKeyRequest, opts ...grpc.CallOption) (*BlobMetaResponse, error) {
	out := new(BlobMetaResponse)
	err := c.cc.Invoke(ctx, "/BlobUploadService/UploadBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlobUploadServiceServer is the server API for BlobUploadService service.
// All implementations must embed UnimplementedBlobUploadServiceServer
// for forward compatibility
type BlobUploadServiceServer interface {
	UploadBlob(context.Context, *UploadKeyRequest) (*BlobMetaResponse, error)
	mustEmbedUnimplementedBlobUploadServiceServer()
}

// UnimplementedBlobUploadServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlobUploadServiceServer struct {
}

func (UnimplementedBlobUploadServiceServer) UploadBlob(context.Context, *UploadKeyRequest) (*BlobMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadBlob not implemented")
}
func (UnimplementedBlobUploadServiceServer) mustEmbedUnimplementedBlobUploadServiceServer() {}

// UnsafeBlobUploadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobUploadServiceServer will
// result in compilation errors.
type UnsafeBlobUploadServiceServer interface {
	mustEmbedUnimplementedBlobUploadServiceServer()
}

func RegisterBlobUploadServiceServer(s grpc.ServiceRegistrar, srv BlobUploadServiceServer) {
	s.RegisterService(&BlobUploadService_ServiceDesc, srv)
}

func _BlobUploadService_UploadBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobUploadServiceServer).UploadBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/BlobUploadService/UploadBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobUploadServiceServer).UploadBlob(ctx, req.(*UploadKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlobUploadService_ServiceDesc is the grpc.ServiceDesc for BlobUploadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobUploadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BlobUploadService",
	HandlerType: (*BlobUploadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadBlob",
			Handler:    _BlobUploadService_UploadBlob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// BlobDownloadServiceClient is the client API for BlobDownloadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobDownloadServiceClient interface {
	DownloadBlobById(ctx context.Context, in *BlobDownloadRequest, opts ...grpc.CallOption) (BlobDownloadService_DownloadBlobByIdClient, error)
}

type blobDownloadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobDownloadServiceClient(cc grpc.ClientConnInterface) BlobDownloadServiceClient {
	return &blobDownloadServiceClient{cc}
}

func (c *blobDownloadServiceClient) DownloadBlobById(ctx context.Context, in *BlobDownloadRequest, opts ...grpc.CallOption) (BlobDownloadService_DownloadBlobByIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &BlobDownloadService_ServiceDesc.Streams[0], "/BlobDownloadService/DownloadBlobById", opts...)
	if err != nil {
		return nil, err
	}
	x := &blobDownloadServiceDownloadBlobByIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BlobDownloadService_DownloadBlobByIdClient interface {
	Recv() (*BlobContent, error)
	grpc.ClientStream
}

type blobDownloadServiceDownloadBlobByIdClient struct {
	grpc.ClientStream
}

func (x *blobDownloadServiceDownloadBlobByIdClient) Recv() (*BlobContent, error) {
	m := new(BlobContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BlobDownloadServiceServer is the server API for BlobDownloadService service.
// All implementations must embed UnimplementedBlobDownloadServiceServer
// for forward compatibility
type BlobDownloadServiceServer interface {
	DownloadBlobById(*BlobDownloadRequest, BlobDownloadService_DownloadBlobByIdServer) error
	mustEmbedUnimplementedBlobDownloadServiceServer()
}

// UnimplementedBlobDownloadServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlobDownloadServiceServer struct {
}

func (UnimplementedBlobDownloadServiceServer) DownloadBlobById(*BlobDownloadRequest, BlobDownloadService_DownloadBlobByIdServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadBlobById not implemented")
}
func (UnimplementedBlobDownloadServiceServer) mustEmbedUnimplementedBlobDownloadServiceServer() {}

// UnsafeBlobDownloadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobDownloadServiceServer will
// result in compilation errors.
type UnsafeBlobDownloadServiceServer interface {
	mustEmbedUnimplementedBlobDownloadServiceServer()
}

func RegisterBlobDownloadServiceServer(s grpc.ServiceRegistrar, srv BlobDownloadServiceServer) {
	s.RegisterService(&BlobDownloadService_ServiceDesc, srv)
}

func _BlobDownloadService_DownloadBlobById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlobDownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlobDownloadServiceServer).DownloadBlobById(m, &blobDownloadServiceDownloadBlobByIdServer{stream})
}

type BlobDownloadService_DownloadBlobByIdServer interface {
	Send(*BlobContent) error
	grpc.ServerStream
}

type blobDownloadServiceDownloadBlobByIdServer struct {
	grpc.ServerStream
}

func (x *blobDownloadServiceDownloadBlobByIdServer) Send(m *BlobContent) error {
	return x.ServerStream.SendMsg(m)
}

// BlobDownloadService_ServiceDesc is the grpc.ServiceDesc for BlobDownloadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobDownloadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BlobDownloadService",
	HandlerType: (*BlobDownloadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadBlobById",
			Handler:       _BlobDownloadService_DownloadBlobById_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

// BlobMetadataServiceClient is the client API for BlobMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobMetadataServiceClient interface {
	ListBlobMetadata(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (BlobMetadataService_ListBlobMetadataClient, error)
	GetBlobMetadataById(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (*BlobMetaResponse, error)
	DeleteBlobById(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (*InfoResponse, error)
}

type blobMetadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobMetadataServiceClient(cc grpc.ClientConnInterface) BlobMetadataServiceClient {
	return &blobMetadataServiceClient{cc}
}

func (c *blobMetadataServiceClient) ListBlobMetadata(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (BlobMetadataService_ListBlobMetadataClient, error) {
	stream, err := c.cc.NewStream(ctx, &BlobMetadataService_ServiceDesc.Streams[0], "/BlobMetadataService/ListBlobMetadata", opts...)
	if err != nil {
		return nil, err
	}
	x := &blobMetadataServiceListBlobMetadataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BlobMetadataService_ListBlobMetadataClient interface {
	Recv() (*BlobMetaResponse, error)
	grpc.ClientStream
}

type blobMetadataServiceListBlobMetadataClient struct {
	grpc.ClientStream
}

func (x *blobMetadataServiceListBlobMetadataClient) Recv() (*BlobMetaResponse, error) {
	m := new(BlobMetaResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blobMetadataServiceClient) GetBlobMetadataById(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (*BlobMetaResponse, error) {
	out := new(BlobMetaResponse)
	err := c.cc.Invoke(ctx, "/BlobMetadataService/GetBlobMetadataById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobMetadataServiceClient) DeleteBlobById(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, "/BlobMetadataService/DeleteBlobById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlobMetadataServiceServer is the server API for BlobMetadataService service.
// All implementations must embed UnimplementedBlobMetadataServiceServer
// for forward compatibility
type BlobMetadataServiceServer interface {
	ListBlobMetadata(*BlobMetaQuery, BlobMetadataService_ListBlobMetadataServer) error
	GetBlobMetadataById(context.Context, *BlobMetaQuery) (*BlobMetaResponse, error)
	DeleteBlobById(context.Context, *BlobMetaQuery) (*InfoResponse, error)
	mustEmbedUnimplementedBlobMetadataServiceServer()
}

// UnimplementedBlobMetadataServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlobMetadataServiceServer struct {
}

func (UnimplementedBlobMetadataServiceServer) ListBlobMetadata(*BlobMetaQuery, BlobMetadataService_ListBlobMetadataServer) error {
	return status.Errorf(codes.Unimplemented, "method ListBlobMetadata not implemented")
}
func (UnimplementedBlobMetadataServiceServer) GetBlobMetadataById(context.Context, *BlobMetaQuery) (*BlobMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobMetadataById not implemented")
}
func (UnimplementedBlobMetadataServiceServer) DeleteBlobById(context.Context, *BlobMetaQuery) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBlobById not implemented")
}
func (UnimplementedBlobMetadataServiceServer) mustEmbedUnimplementedBlobMetadataServiceServer() {}

// UnsafeBlobMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobMetadataServiceServer will
// result in compilation errors.
type UnsafeBlobMetadataServiceServer interface {
	mustEmbedUnimplementedBlobMetadataServiceServer()
}

func RegisterBlobMetadataServiceServer(s grpc.ServiceRegistrar, srv BlobMetadataServiceServer) {
	s.RegisterService(&BlobMetadataService_ServiceDesc, srv)
}

func _BlobMetadataService_ListBlobMetadata_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlobMetaQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlobMetadataServiceServer).ListBlobMetadata(m, &blobMetadataServiceListBlobMetadataServer{stream})
}

type BlobMetadataService_ListBlobMetadataServer interface {
	Send(*BlobMetaResponse) error
	grpc.ServerStream
}

type blobMetadataServiceListBlobMetadataServer struct {
	grpc.ServerStream
}

func (x *blobMetadataServiceListBlobMetadataServer) Send(m *BlobMetaResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BlobMetadataService_GetBlobMetadataById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobMetaQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobMetadataServiceServer).GetBlobMetadataById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/BlobMetadataService/GetBlobMetadataById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobMetadataServiceServer).GetBlobMetadataById(ctx, req.(*BlobMetaQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlobMetadataService_DeleteBlobById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobMetaQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobMetadataServiceServer).DeleteBlobById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/BlobMetadataService/DeleteBlobById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobMetadataServiceServer).DeleteBlobById(ctx, req.(*BlobMetaQuery))
	}
	return interceptor(ctx, in, info, handler)
}

// BlobMetadataService_ServiceDesc is the grpc.ServiceDesc for BlobMetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobMetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BlobMetadataService",
	HandlerType: (*BlobMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlobMetadataById",
			Handler:    _BlobMetadataService_GetBlobMetadataById_Handler,
		},
		{
			MethodName: "DeleteBlobById",
			Handler:    _BlobMetadataService_DeleteBlobById_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListBlobMetadata",
			Handler:       _BlobMetadataService_ListBlobMetadata_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

// CryptoKeyUploadServiceClient is the client API for CryptoKeyUploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoKeyUploadServiceClient interface {
	UploadKey(ctx context.Context, in *UploadKeyRequest, opts ...grpc.CallOption) (*CryptoKeyMetaResponse, error)
}

type cryptoKeyUploadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoKeyUploadServiceClient(cc grpc.ClientConnInterface) CryptoKeyUploadServiceClient {
	return &cryptoKeyUploadServiceClient{cc}
}

func (c *cryptoKeyUploadServiceClient) UploadKey(ctx context.Context, in *UploadKeyRequest, opts ...grpc.CallOption) (*CryptoKeyMetaResponse, error) {
	out := new(CryptoKeyMetaResponse)
	err := c.cc.Invoke(ctx, "/CryptoKeyUploadService/UploadKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoKeyUploadServiceServer is the server API for CryptoKeyUploadService service.
// All implementations must embed UnimplementedCryptoKeyUploadServiceServer
// for forward compatibility
type CryptoKeyUploadServiceServer interface {
	UploadKey(context.Context, *UploadKeyRequest) (*CryptoKeyMetaResponse, error)
	mustEmbedUnimplementedCryptoKeyUploadServiceServer()
}

// UnimplementedCryptoKeyUploadServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoKeyUploadServiceServer struct {
}

func (UnimplementedCryptoKeyUploadServiceServer) UploadKey(context.Context, *UploadKeyRequest) (*CryptoKeyMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadKey not implemented")
}
func (UnimplementedCryptoKeyUploadServiceServer) mustEmbedUnimplementedCryptoKeyUploadServiceServer() {
}

// UnsafeCryptoKeyUploadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoKeyUploadServiceServer will
// result in compilation errors.
type UnsafeCryptoKeyUploadServiceServer interface {
	mustEmbedUnimplementedCryptoKeyUploadServiceServer()
}

func RegisterCryptoKeyUploadServiceServer(s grpc.ServiceRegistrar, srv CryptoKeyUploadServiceServer) {
	s.RegisterService(&CryptoKeyUploadService_ServiceDesc, srv)
}

func _CryptoKeyUploadService_UploadKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoKeyUploadServiceServer).UploadKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CryptoKeyUploadService/UploadKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoKeyUploadServiceServer).UploadKey(ctx, req.(*UploadKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoKeyUploadService_ServiceDesc is the grpc.ServiceDesc for CryptoKeyUploadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoKeyUploadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CryptoKeyUploadService",
	HandlerType: (*CryptoKeyUploadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadKey",
			Handler:    _CryptoKeyUploadService_UploadKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// CryptoKeyDownloadServiceClient is the client API for CryptoKeyDownloadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoKeyDownloadServiceClient interface {
	DownloadKeyById(ctx context.Context, in *KeyDownloadRequest, opts ...grpc.CallOption) (CryptoKeyDownloadService_DownloadKeyByIdClient, error)
}

type cryptoKeyDownloadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoKeyDownloadServiceClient(cc grpc.ClientConnInterface) CryptoKeyDownloadServiceClient {
	return &cryptoKeyDownloadServiceClient{cc}
}

func (c *cryptoKeyDownloadServiceClient) DownloadKeyById(ctx context.Context, in *KeyDownloadRequest, opts ...grpc.CallOption) (CryptoKeyDownloadService_DownloadKeyByIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &CryptoKeyDownloadService_ServiceDesc.Streams[0], "/CryptoKeyDownloadService/DownloadKeyById", opts...)
	if err != nil {
		return nil, err
	}
	x := &cryptoKeyDownloadServiceDownloadKeyByIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CryptoKeyDownloadService_DownloadKeyByIdClient interface {
	Recv() (*KeyContent, error)
	grpc.ClientStream
}

type cryptoKeyDownloadServiceDownloadKeyByIdClient struct {
	grpc.ClientStream
}

func (x *cryptoKeyDownloadServiceDownloadKeyByIdClient) Recv() (*KeyContent, error) {
	m := new(KeyContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CryptoKeyDownloadServiceServer is the server API for CryptoKeyDownloadService service.
// All implementations must embed UnimplementedCryptoKeyDownloadServiceServer
// for forward compatibility
type CryptoKeyDownloadServiceServer interface {
	DownloadKeyById(*KeyDownloadRequest, CryptoKeyDownloadService_DownloadKeyByIdServer) error
	mustEmbedUnimplementedCryptoKeyDownloadServiceServer()
}

// UnimplementedCryptoKeyDownloadServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoKeyDownloadServiceServer struct {
}

func (UnimplementedCryptoKeyDownloadServiceServer) DownloadKeyById(*KeyDownloadRequest, CryptoKeyDownloadService_DownloadKeyByIdServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadKeyById not implemented")
}
func (UnimplementedCryptoKeyDownloadServiceServer) mustEmbedUnimplementedCryptoKeyDownloadServiceServer() {
}

// UnsafeCryptoKeyDownloadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoKeyDownloadServiceServer will
// result in compilation errors.
type UnsafeCryptoKeyDownloadServiceServer interface {
	mustEmbedUnimplementedCryptoKeyDownloadServiceServer()
}

func RegisterCryptoKeyDownloadServiceServer(s grpc.ServiceRegistrar, srv CryptoKeyDownloadServiceServer) {
	s.RegisterService(&CryptoKeyDownloadService_ServiceDesc, srv)
}

func _CryptoKeyDownloadService_DownloadKeyById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KeyDownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CryptoKeyDownloadServiceServer).DownloadKeyById(m, &cryptoKeyDownloadServiceDownloadKeyByIdServer{stream})
}

type CryptoKeyDownloadService_DownloadKeyByIdServer interface {
	Send(*KeyContent) error
	grpc.ServerStream
}

type cryptoKeyDownloadServiceDownloadKeyByIdServer struct {
	grpc.ServerStream
}

func (x *cryptoKeyDownloadServiceDownloadKeyByIdServer) Send(m *KeyContent) error {
	return x.ServerStream.SendMsg(m)
}

// CryptoKeyDownloadService_ServiceDesc is the grpc.ServiceDesc for CryptoKeyDownloadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoKeyDownloadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CryptoKeyDownloadService",
	HandlerType: (*CryptoKeyDownloadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadKeyById",
			Handler:       _CryptoKeyDownloadService_DownloadKeyById_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

// CryptoKeyMetadataServiceClient is the client API for CryptoKeyMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoKeyMetadataServiceClient interface {
	ListKeyMetadata(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (CryptoKeyMetadataService_ListKeyMetadataClient, error)
	GetKeyMetadataById(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (*CryptoKeyMetaResponse, error)
	DeleteKeyById(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (*InfoResponse, error)
}

type cryptoKeyMetadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoKeyMetadataServiceClient(cc grpc.ClientConnInterface) CryptoKeyMetadataServiceClient {
	return &cryptoKeyMetadataServiceClient{cc}
}

func (c *cryptoKeyMetadataServiceClient) ListKeyMetadata(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (CryptoKeyMetadataService_ListKeyMetadataClient, error) {
	stream, err := c.cc.NewStream(ctx, &CryptoKeyMetadataService_ServiceDesc.Streams[0], "/CryptoKeyMetadataService/ListKeyMetadata", opts...)
	if err != nil {
		return nil, err
	}
	x := &cryptoKeyMetadataServiceListKeyMetadataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CryptoKeyMetadataService_ListKeyMetadataClient interface {
	Recv() (*CryptoKeyMetaResponse, error)
	grpc.ClientStream
}

type cryptoKeyMetadataServiceListKeyMetadataClient struct {
	grpc.ClientStream
}

func (x *cryptoKeyMetadataServiceListKeyMetadataClient) Recv() (*CryptoKeyMetaResponse, error) {
	m := new(CryptoKeyMetaResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cryptoKeyMetadataServiceClient) GetKeyMetadataById(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (*CryptoKeyMetaResponse, error) {
	out := new(CryptoKeyMetaResponse)
	err := c.cc.Invoke(ctx, "/CryptoKeyMetadataService/GetKeyMetadataById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoKeyMetadataServiceClient) DeleteKeyById(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, "/CryptoKeyMetadataService/DeleteKeyById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoKeyMetadataServiceServer is the server API for CryptoKeyMetadataService service.
// All implementations must embed UnimplementedCryptoKeyMetadataServiceServer
// for forward compatibility
type CryptoKeyMetadataServiceServer interface {
	ListKeyMetadata(*KeyMetadataQuery, CryptoKeyMetadataService_ListKeyMetadataServer) error
	GetKeyMetadataById(context.Context, *KeyMetadataQuery) (*CryptoKeyMetaResponse, error)
	DeleteKeyById(context.Context, *KeyMetadataQuery) (*InfoResponse, error)
	mustEmbedUnimplementedCryptoKeyMetadataServiceServer()
}

// UnimplementedCryptoKeyMetadataServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoKeyMetadataServiceServer struct {
}

func (UnimplementedCryptoKeyMetadataServiceServer) ListKeyMetadata(*KeyMetadataQuery, CryptoKeyMetadataService_ListKeyMetadataServer) error {
	return status.Errorf(codes.Unimplemented, "method ListKeyMetadata not implemented")
}
func (UnimplementedCryptoKeyMetadataServiceServer) GetKeyMetadataById(context.Context, *KeyMetadataQuery) (*CryptoKeyMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyMetadataById not implemented")
}
func (UnimplementedCryptoKeyMetadataServiceServer) DeleteKeyById(context.Context, *KeyMetadataQuery) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKeyById not implemented")
}
func (UnimplementedCryptoKeyMetadataServiceServer) mustEmbedUnimplementedCryptoKeyMetadataServiceServer() {
}

// UnsafeCryptoKeyMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoKeyMetadataServiceServer will
// result in compilation errors.
type UnsafeCryptoKeyMetadataServiceServer interface {
	mustEmbedUnimplementedCryptoKeyMetadataServiceServer()
}

func RegisterCryptoKeyMetadataServiceServer(s grpc.ServiceRegistrar, srv CryptoKeyMetadataServiceServer) {
	s.RegisterService(&CryptoKeyMetadataService_ServiceDesc, srv)
}

func _CryptoKeyMetadataService_ListKeyMetadata_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KeyMetadataQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CryptoKeyMetadataServiceServer).ListKeyMetadata(m, &cryptoKeyMetadataServiceListKeyMetadataServer{stream})
}

type CryptoKeyMetadataService_ListKeyMetadataServer interface {
	Send(*CryptoKeyMetaResponse) error
	grpc.ServerStream
}

type cryptoKeyMetadataServiceListKeyMetadataServer struct {
	grpc.ServerStream
}

func (x *cryptoKeyMetadataServiceListKeyMetadataServer) Send(m *CryptoKeyMetaResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CryptoKeyMetadataService_GetKeyMetadataById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMetadataQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoKeyMetadataServiceServer).GetKeyMetadataById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CryptoKeyMetadataService/GetKeyMetadataById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoKeyMetadataServiceServer).GetKeyMetadataById(ctx, req.(*KeyMetadataQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoKeyMetadataService_DeleteKeyById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMetadataQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoKeyMetadataServiceServer).DeleteKeyById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CryptoKeyMetadataService/DeleteKeyById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoKeyMetadataServiceServer).DeleteKeyById(ctx, req.(*KeyMetadataQuery))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoKeyMetadataService_ServiceDesc is the grpc.ServiceDesc for CryptoKeyMetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoKeyMetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CryptoKeyMetadataService",
	HandlerType: (*CryptoKeyMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKeyMetadataById",
			Handler:    _CryptoKeyMetadataService_GetKeyMetadataById_Handler,
		},
		{
			MethodName: "DeleteKeyById",
			Handler:    _CryptoKeyMetadataService_DeleteKeyById_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListKeyMetadata",
			Handler:       _CryptoKeyMetadataService_ListKeyMetadata_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}
