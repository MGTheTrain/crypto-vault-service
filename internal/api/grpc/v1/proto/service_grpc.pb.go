// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: service.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BlobUploadService_Upload_FullMethodName = "/BlobUploadService/Upload"
)

// BlobUploadServiceClient is the client API for BlobUploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobUploadServiceClient interface {
	Upload(ctx context.Context, in *BlobUploadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlobMetaResponse], error)
}

type blobUploadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobUploadServiceClient(cc grpc.ClientConnInterface) BlobUploadServiceClient {
	return &blobUploadServiceClient{cc}
}

func (c *blobUploadServiceClient) Upload(ctx context.Context, in *BlobUploadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlobMetaResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BlobUploadService_ServiceDesc.Streams[0], BlobUploadService_Upload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlobUploadRequest, BlobMetaResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BlobUploadService_UploadClient = grpc.ServerStreamingClient[BlobMetaResponse]

// BlobUploadServiceServer is the server API for BlobUploadService service.
// All implementations must embed UnimplementedBlobUploadServiceServer
// for forward compatibility.
type BlobUploadServiceServer interface {
	Upload(*BlobUploadRequest, grpc.ServerStreamingServer[BlobMetaResponse]) error
	mustEmbedUnimplementedBlobUploadServiceServer()
}

// UnimplementedBlobUploadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBlobUploadServiceServer struct{}

func (UnimplementedBlobUploadServiceServer) Upload(*BlobUploadRequest, grpc.ServerStreamingServer[BlobMetaResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedBlobUploadServiceServer) mustEmbedUnimplementedBlobUploadServiceServer() {}
func (UnimplementedBlobUploadServiceServer) testEmbeddedByValue()                           {}

// UnsafeBlobUploadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobUploadServiceServer will
// result in compilation errors.
type UnsafeBlobUploadServiceServer interface {
	mustEmbedUnimplementedBlobUploadServiceServer()
}

func RegisterBlobUploadServiceServer(s grpc.ServiceRegistrar, srv BlobUploadServiceServer) {
	// If the following call pancis, it indicates UnimplementedBlobUploadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BlobUploadService_ServiceDesc, srv)
}

func _BlobUploadService_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlobUploadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlobUploadServiceServer).Upload(m, &grpc.GenericServerStream[BlobUploadRequest, BlobMetaResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BlobUploadService_UploadServer = grpc.ServerStreamingServer[BlobMetaResponse]

// BlobUploadService_ServiceDesc is the grpc.ServiceDesc for BlobUploadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobUploadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BlobUploadService",
	HandlerType: (*BlobUploadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _BlobUploadService_Upload_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	BlobDownloadService_DownloadById_FullMethodName = "/BlobDownloadService/DownloadById"
)

// BlobDownloadServiceClient is the client API for BlobDownloadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobDownloadServiceClient interface {
	DownloadById(ctx context.Context, in *BlobDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlobContent], error)
}

type blobDownloadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobDownloadServiceClient(cc grpc.ClientConnInterface) BlobDownloadServiceClient {
	return &blobDownloadServiceClient{cc}
}

func (c *blobDownloadServiceClient) DownloadById(ctx context.Context, in *BlobDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlobContent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BlobDownloadService_ServiceDesc.Streams[0], BlobDownloadService_DownloadById_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlobDownloadRequest, BlobContent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BlobDownloadService_DownloadByIdClient = grpc.ServerStreamingClient[BlobContent]

// BlobDownloadServiceServer is the server API for BlobDownloadService service.
// All implementations must embed UnimplementedBlobDownloadServiceServer
// for forward compatibility.
type BlobDownloadServiceServer interface {
	DownloadById(*BlobDownloadRequest, grpc.ServerStreamingServer[BlobContent]) error
	mustEmbedUnimplementedBlobDownloadServiceServer()
}

// UnimplementedBlobDownloadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBlobDownloadServiceServer struct{}

func (UnimplementedBlobDownloadServiceServer) DownloadById(*BlobDownloadRequest, grpc.ServerStreamingServer[BlobContent]) error {
	return status.Errorf(codes.Unimplemented, "method DownloadById not implemented")
}
func (UnimplementedBlobDownloadServiceServer) mustEmbedUnimplementedBlobDownloadServiceServer() {}
func (UnimplementedBlobDownloadServiceServer) testEmbeddedByValue()                             {}

// UnsafeBlobDownloadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobDownloadServiceServer will
// result in compilation errors.
type UnsafeBlobDownloadServiceServer interface {
	mustEmbedUnimplementedBlobDownloadServiceServer()
}

func RegisterBlobDownloadServiceServer(s grpc.ServiceRegistrar, srv BlobDownloadServiceServer) {
	// If the following call pancis, it indicates UnimplementedBlobDownloadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BlobDownloadService_ServiceDesc, srv)
}

func _BlobDownloadService_DownloadById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlobDownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlobDownloadServiceServer).DownloadById(m, &grpc.GenericServerStream[BlobDownloadRequest, BlobContent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BlobDownloadService_DownloadByIdServer = grpc.ServerStreamingServer[BlobContent]

// BlobDownloadService_ServiceDesc is the grpc.ServiceDesc for BlobDownloadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobDownloadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BlobDownloadService",
	HandlerType: (*BlobDownloadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadById",
			Handler:       _BlobDownloadService_DownloadById_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	BlobMetadataService_ListMetadata_FullMethodName    = "/BlobMetadataService/ListMetadata"
	BlobMetadataService_GetMetadataById_FullMethodName = "/BlobMetadataService/GetMetadataById"
	BlobMetadataService_DeleteById_FullMethodName      = "/BlobMetadataService/DeleteById"
)

// BlobMetadataServiceClient is the client API for BlobMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobMetadataServiceClient interface {
	ListMetadata(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlobMetaResponse], error)
	GetMetadataById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*BlobMetaResponse, error)
	DeleteById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*InfoResponse, error)
}

type blobMetadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobMetadataServiceClient(cc grpc.ClientConnInterface) BlobMetadataServiceClient {
	return &blobMetadataServiceClient{cc}
}

func (c *blobMetadataServiceClient) ListMetadata(ctx context.Context, in *BlobMetaQuery, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlobMetaResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BlobMetadataService_ServiceDesc.Streams[0], BlobMetadataService_ListMetadata_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlobMetaQuery, BlobMetaResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BlobMetadataService_ListMetadataClient = grpc.ServerStreamingClient[BlobMetaResponse]

func (c *blobMetadataServiceClient) GetMetadataById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*BlobMetaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlobMetaResponse)
	err := c.cc.Invoke(ctx, BlobMetadataService_GetMetadataById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobMetadataServiceClient) DeleteById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, BlobMetadataService_DeleteById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlobMetadataServiceServer is the server API for BlobMetadataService service.
// All implementations must embed UnimplementedBlobMetadataServiceServer
// for forward compatibility.
type BlobMetadataServiceServer interface {
	ListMetadata(*BlobMetaQuery, grpc.ServerStreamingServer[BlobMetaResponse]) error
	GetMetadataById(context.Context, *IdRequest) (*BlobMetaResponse, error)
	DeleteById(context.Context, *IdRequest) (*InfoResponse, error)
	mustEmbedUnimplementedBlobMetadataServiceServer()
}

// UnimplementedBlobMetadataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBlobMetadataServiceServer struct{}

func (UnimplementedBlobMetadataServiceServer) ListMetadata(*BlobMetaQuery, grpc.ServerStreamingServer[BlobMetaResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ListMetadata not implemented")
}
func (UnimplementedBlobMetadataServiceServer) GetMetadataById(context.Context, *IdRequest) (*BlobMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadataById not implemented")
}
func (UnimplementedBlobMetadataServiceServer) DeleteById(context.Context, *IdRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteById not implemented")
}
func (UnimplementedBlobMetadataServiceServer) mustEmbedUnimplementedBlobMetadataServiceServer() {}
func (UnimplementedBlobMetadataServiceServer) testEmbeddedByValue()                             {}

// UnsafeBlobMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobMetadataServiceServer will
// result in compilation errors.
type UnsafeBlobMetadataServiceServer interface {
	mustEmbedUnimplementedBlobMetadataServiceServer()
}

func RegisterBlobMetadataServiceServer(s grpc.ServiceRegistrar, srv BlobMetadataServiceServer) {
	// If the following call pancis, it indicates UnimplementedBlobMetadataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BlobMetadataService_ServiceDesc, srv)
}

func _BlobMetadataService_ListMetadata_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlobMetaQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlobMetadataServiceServer).ListMetadata(m, &grpc.GenericServerStream[BlobMetaQuery, BlobMetaResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BlobMetadataService_ListMetadataServer = grpc.ServerStreamingServer[BlobMetaResponse]

func _BlobMetadataService_GetMetadataById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobMetadataServiceServer).GetMetadataById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlobMetadataService_GetMetadataById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobMetadataServiceServer).GetMetadataById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlobMetadataService_DeleteById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobMetadataServiceServer).DeleteById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlobMetadataService_DeleteById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobMetadataServiceServer).DeleteById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlobMetadataService_ServiceDesc is the grpc.ServiceDesc for BlobMetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobMetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BlobMetadataService",
	HandlerType: (*BlobMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMetadataById",
			Handler:    _BlobMetadataService_GetMetadataById_Handler,
		},
		{
			MethodName: "DeleteById",
			Handler:    _BlobMetadataService_DeleteById_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListMetadata",
			Handler:       _BlobMetadataService_ListMetadata_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	CryptoKeyUploadService_Upload_FullMethodName = "/CryptoKeyUploadService/Upload"
)

// CryptoKeyUploadServiceClient is the client API for CryptoKeyUploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoKeyUploadServiceClient interface {
	Upload(ctx context.Context, in *UploadKeyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CryptoKeyMetaResponse], error)
}

type cryptoKeyUploadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoKeyUploadServiceClient(cc grpc.ClientConnInterface) CryptoKeyUploadServiceClient {
	return &cryptoKeyUploadServiceClient{cc}
}

func (c *cryptoKeyUploadServiceClient) Upload(ctx context.Context, in *UploadKeyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CryptoKeyMetaResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CryptoKeyUploadService_ServiceDesc.Streams[0], CryptoKeyUploadService_Upload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UploadKeyRequest, CryptoKeyMetaResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CryptoKeyUploadService_UploadClient = grpc.ServerStreamingClient[CryptoKeyMetaResponse]

// CryptoKeyUploadServiceServer is the server API for CryptoKeyUploadService service.
// All implementations must embed UnimplementedCryptoKeyUploadServiceServer
// for forward compatibility.
type CryptoKeyUploadServiceServer interface {
	Upload(*UploadKeyRequest, grpc.ServerStreamingServer[CryptoKeyMetaResponse]) error
	mustEmbedUnimplementedCryptoKeyUploadServiceServer()
}

// UnimplementedCryptoKeyUploadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCryptoKeyUploadServiceServer struct{}

func (UnimplementedCryptoKeyUploadServiceServer) Upload(*UploadKeyRequest, grpc.ServerStreamingServer[CryptoKeyMetaResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedCryptoKeyUploadServiceServer) mustEmbedUnimplementedCryptoKeyUploadServiceServer() {
}
func (UnimplementedCryptoKeyUploadServiceServer) testEmbeddedByValue() {}

// UnsafeCryptoKeyUploadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoKeyUploadServiceServer will
// result in compilation errors.
type UnsafeCryptoKeyUploadServiceServer interface {
	mustEmbedUnimplementedCryptoKeyUploadServiceServer()
}

func RegisterCryptoKeyUploadServiceServer(s grpc.ServiceRegistrar, srv CryptoKeyUploadServiceServer) {
	// If the following call pancis, it indicates UnimplementedCryptoKeyUploadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CryptoKeyUploadService_ServiceDesc, srv)
}

func _CryptoKeyUploadService_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UploadKeyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CryptoKeyUploadServiceServer).Upload(m, &grpc.GenericServerStream[UploadKeyRequest, CryptoKeyMetaResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CryptoKeyUploadService_UploadServer = grpc.ServerStreamingServer[CryptoKeyMetaResponse]

// CryptoKeyUploadService_ServiceDesc is the grpc.ServiceDesc for CryptoKeyUploadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoKeyUploadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CryptoKeyUploadService",
	HandlerType: (*CryptoKeyUploadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _CryptoKeyUploadService_Upload_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	CryptoKeyDownloadService_DownloadById_FullMethodName = "/CryptoKeyDownloadService/DownloadById"
)

// CryptoKeyDownloadServiceClient is the client API for CryptoKeyDownloadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoKeyDownloadServiceClient interface {
	DownloadById(ctx context.Context, in *KeyDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[KeyContent], error)
}

type cryptoKeyDownloadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoKeyDownloadServiceClient(cc grpc.ClientConnInterface) CryptoKeyDownloadServiceClient {
	return &cryptoKeyDownloadServiceClient{cc}
}

func (c *cryptoKeyDownloadServiceClient) DownloadById(ctx context.Context, in *KeyDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[KeyContent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CryptoKeyDownloadService_ServiceDesc.Streams[0], CryptoKeyDownloadService_DownloadById_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[KeyDownloadRequest, KeyContent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CryptoKeyDownloadService_DownloadByIdClient = grpc.ServerStreamingClient[KeyContent]

// CryptoKeyDownloadServiceServer is the server API for CryptoKeyDownloadService service.
// All implementations must embed UnimplementedCryptoKeyDownloadServiceServer
// for forward compatibility.
type CryptoKeyDownloadServiceServer interface {
	DownloadById(*KeyDownloadRequest, grpc.ServerStreamingServer[KeyContent]) error
	mustEmbedUnimplementedCryptoKeyDownloadServiceServer()
}

// UnimplementedCryptoKeyDownloadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCryptoKeyDownloadServiceServer struct{}

func (UnimplementedCryptoKeyDownloadServiceServer) DownloadById(*KeyDownloadRequest, grpc.ServerStreamingServer[KeyContent]) error {
	return status.Errorf(codes.Unimplemented, "method DownloadById not implemented")
}
func (UnimplementedCryptoKeyDownloadServiceServer) mustEmbedUnimplementedCryptoKeyDownloadServiceServer() {
}
func (UnimplementedCryptoKeyDownloadServiceServer) testEmbeddedByValue() {}

// UnsafeCryptoKeyDownloadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoKeyDownloadServiceServer will
// result in compilation errors.
type UnsafeCryptoKeyDownloadServiceServer interface {
	mustEmbedUnimplementedCryptoKeyDownloadServiceServer()
}

func RegisterCryptoKeyDownloadServiceServer(s grpc.ServiceRegistrar, srv CryptoKeyDownloadServiceServer) {
	// If the following call pancis, it indicates UnimplementedCryptoKeyDownloadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CryptoKeyDownloadService_ServiceDesc, srv)
}

func _CryptoKeyDownloadService_DownloadById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KeyDownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CryptoKeyDownloadServiceServer).DownloadById(m, &grpc.GenericServerStream[KeyDownloadRequest, KeyContent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CryptoKeyDownloadService_DownloadByIdServer = grpc.ServerStreamingServer[KeyContent]

// CryptoKeyDownloadService_ServiceDesc is the grpc.ServiceDesc for CryptoKeyDownloadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoKeyDownloadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CryptoKeyDownloadService",
	HandlerType: (*CryptoKeyDownloadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadById",
			Handler:       _CryptoKeyDownloadService_DownloadById_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	CryptoKeyMetadataService_ListMetadata_FullMethodName    = "/CryptoKeyMetadataService/ListMetadata"
	CryptoKeyMetadataService_GetMetadataById_FullMethodName = "/CryptoKeyMetadataService/GetMetadataById"
	CryptoKeyMetadataService_DeleteById_FullMethodName      = "/CryptoKeyMetadataService/DeleteById"
)

// CryptoKeyMetadataServiceClient is the client API for CryptoKeyMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoKeyMetadataServiceClient interface {
	ListMetadata(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CryptoKeyMetaResponse], error)
	GetMetadataById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*CryptoKeyMetaResponse, error)
	DeleteById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*InfoResponse, error)
}

type cryptoKeyMetadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoKeyMetadataServiceClient(cc grpc.ClientConnInterface) CryptoKeyMetadataServiceClient {
	return &cryptoKeyMetadataServiceClient{cc}
}

func (c *cryptoKeyMetadataServiceClient) ListMetadata(ctx context.Context, in *KeyMetadataQuery, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CryptoKeyMetaResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CryptoKeyMetadataService_ServiceDesc.Streams[0], CryptoKeyMetadataService_ListMetadata_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[KeyMetadataQuery, CryptoKeyMetaResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CryptoKeyMetadataService_ListMetadataClient = grpc.ServerStreamingClient[CryptoKeyMetaResponse]

func (c *cryptoKeyMetadataServiceClient) GetMetadataById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*CryptoKeyMetaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CryptoKeyMetaResponse)
	err := c.cc.Invoke(ctx, CryptoKeyMetadataService_GetMetadataById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoKeyMetadataServiceClient) DeleteById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, CryptoKeyMetadataService_DeleteById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoKeyMetadataServiceServer is the server API for CryptoKeyMetadataService service.
// All implementations must embed UnimplementedCryptoKeyMetadataServiceServer
// for forward compatibility.
type CryptoKeyMetadataServiceServer interface {
	ListMetadata(*KeyMetadataQuery, grpc.ServerStreamingServer[CryptoKeyMetaResponse]) error
	GetMetadataById(context.Context, *IdRequest) (*CryptoKeyMetaResponse, error)
	DeleteById(context.Context, *IdRequest) (*InfoResponse, error)
	mustEmbedUnimplementedCryptoKeyMetadataServiceServer()
}

// UnimplementedCryptoKeyMetadataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCryptoKeyMetadataServiceServer struct{}

func (UnimplementedCryptoKeyMetadataServiceServer) ListMetadata(*KeyMetadataQuery, grpc.ServerStreamingServer[CryptoKeyMetaResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ListMetadata not implemented")
}
func (UnimplementedCryptoKeyMetadataServiceServer) GetMetadataById(context.Context, *IdRequest) (*CryptoKeyMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadataById not implemented")
}
func (UnimplementedCryptoKeyMetadataServiceServer) DeleteById(context.Context, *IdRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteById not implemented")
}
func (UnimplementedCryptoKeyMetadataServiceServer) mustEmbedUnimplementedCryptoKeyMetadataServiceServer() {
}
func (UnimplementedCryptoKeyMetadataServiceServer) testEmbeddedByValue() {}

// UnsafeCryptoKeyMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoKeyMetadataServiceServer will
// result in compilation errors.
type UnsafeCryptoKeyMetadataServiceServer interface {
	mustEmbedUnimplementedCryptoKeyMetadataServiceServer()
}

func RegisterCryptoKeyMetadataServiceServer(s grpc.ServiceRegistrar, srv CryptoKeyMetadataServiceServer) {
	// If the following call pancis, it indicates UnimplementedCryptoKeyMetadataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CryptoKeyMetadataService_ServiceDesc, srv)
}

func _CryptoKeyMetadataService_ListMetadata_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KeyMetadataQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CryptoKeyMetadataServiceServer).ListMetadata(m, &grpc.GenericServerStream[KeyMetadataQuery, CryptoKeyMetaResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CryptoKeyMetadataService_ListMetadataServer = grpc.ServerStreamingServer[CryptoKeyMetaResponse]

func _CryptoKeyMetadataService_GetMetadataById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoKeyMetadataServiceServer).GetMetadataById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoKeyMetadataService_GetMetadataById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoKeyMetadataServiceServer).GetMetadataById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoKeyMetadataService_DeleteById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoKeyMetadataServiceServer).DeleteById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoKeyMetadataService_DeleteById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoKeyMetadataServiceServer).DeleteById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoKeyMetadataService_ServiceDesc is the grpc.ServiceDesc for CryptoKeyMetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoKeyMetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CryptoKeyMetadataService",
	HandlerType: (*CryptoKeyMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMetadataById",
			Handler:    _CryptoKeyMetadataService_GetMetadataById_Handler,
		},
		{
			MethodName: "DeleteById",
			Handler:    _CryptoKeyMetadataService_DeleteById_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListMetadata",
			Handler:       _CryptoKeyMetadataService_ListMetadata_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}
